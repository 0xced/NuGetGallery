// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Moq;
using NuGet.Services.Entities;
using NuGet.Versioning;
using NuGetGallery.Framework;
using Xunit;

namespace NuGetGallery.Services
{
    public class PackageVulnerabilityServiceFacts
    {
        public class TheUpdateVulnerabilityMethod : MethodFacts
        {
            [Theory]
            [InlineData(false)]
            [InlineData(true)]
            public Task ThrowsArgumentNullExceptionIfNull(bool withdrawn)
            {
                var service = GetService<PackageVulnerabilityService>();
                return Assert.ThrowsAsync<ArgumentNullException>(() => service.UpdateVulnerability(null, withdrawn));
            }

            public static IEnumerable<object[]> WithNoExistingAndIfWithdrawnOrNoPackages_DoesNotAdd_Data
            {
                get
                {
                    var emptyVulnerability = new Vulnerability();
                    yield return new object[] { emptyVulnerability, false };
                    yield return new object[] { emptyVulnerability, true };

                    var packageVulnerability = new PackageVulnerability();
                    var vulnerabilityWithPackageVulnerability = new Vulnerability();
                    vulnerabilityWithPackageVulnerability.PackageVulnerabilities.Add(packageVulnerability);

                    yield return new object[] { vulnerabilityWithPackageVulnerability, true };
                }
            }

            [Theory]
            [MemberData(nameof(WithNoExistingAndIfWithdrawnOrNoPackages_DoesNotAdd_Data))]
            public async Task WithNoExisting_WithdrawnOrNoPackageVulnerabilities_DoesNotAdd(Vulnerability vulnerability, bool withdrawn)
            {
                // Arrange
                var context = GetFakeContext();
                var updateService = GetMock<IPackageUpdateService>();
                var service = GetService<PackageVulnerabilityService>();

                // Act
                await service.UpdateVulnerability(vulnerability, withdrawn);

                // Assert
                Assert.False(context.Vulnerabilities.AnySafe());
                updateService.Verify(
                    x => x.UpdatePackagesAsync(It.IsAny<IReadOnlyList<Package>>(), It.IsAny<bool>()),
                    Times.Never);

                VerifyTransaction();
            }

            [Theory]
            [InlineData(false)]
            [InlineData(true)]
            public async Task WithExisting_Withdrawn_RemovesAndUnmarks(bool hasPackages)
            {
                // Arrange
                var key = 1;
                var vulnerability = new Vulnerability { GitHubDatabaseKey = key };
                var existingVulnerability = new Vulnerability
                {
                    GitHubDatabaseKey = key,
                    Description = "hello"
                };

                var context = GetFakeContext();
                context.Vulnerabilities.Add(existingVulnerability);

                var updateService = GetMock<IPackageUpdateService>();
                if (hasPackages)
                {
                    var package = new Package();
                    var packageVulnerability = new PackageVulnerability();
                    packageVulnerability.Packages.Add(package);
                    existingVulnerability.PackageVulnerabilities.Add(packageVulnerability);

                    updateService
                        .Setup(x => x.UpdatePackagesAsync(new[] { package }, true))
                        .Returns(Task.CompletedTask)
                        .Verifiable();
                }

                var service = GetService<PackageVulnerabilityService>();

                // Act
                await service.UpdateVulnerability(vulnerability, true);

                // Assert
                Assert.False(context.Vulnerabilities.AnySafe());
                updateService.Verify();

                VerifyTransaction();
            }

            public static IEnumerable<object[]> WithExisting_NotWithdrawn_UpdatesPackages_Data =>
                MemberDataHelper.Combine(
                    MemberDataHelper.BooleanDataSet(),
                    MemberDataHelper.BooleanDataSet());

            [Theory]
            [MemberData(nameof(WithExisting_NotWithdrawn_UpdatesPackages_Data))]
            public async Task WithExisting_NotWithdrawn_UpdatesPackages(bool hasPackages, bool wasUpdated)
            {
                // Arrange
                var key = 1;
                var description = "hello";
                var newDescription = "hi";
                var vulnerability = new Vulnerability
                {
                    GitHubDatabaseKey = key,
                    Description = wasUpdated ? newDescription : description
                };

                var existingVulnerability = new Vulnerability
                {
                    GitHubDatabaseKey = key,
                    Description = description
                };

                var context = GetFakeContext();
                context.Vulnerabilities.Add(existingVulnerability);

                var updateService = GetMock<IPackageUpdateService>();
                if (hasPackages)
                {
                    var package = new Package();
                    var packageVulnerability = new PackageVulnerability();
                    packageVulnerability.Packages.Add(package);
                    existingVulnerability.PackageVulnerabilities.Add(packageVulnerability);

                    if (wasUpdated)
                    {
                        updateService
                            .Setup(x => x.UpdatePackagesAsync(new[] { package }, true))
                            .Returns(Task.CompletedTask)
                            .Verifiable();
                    }
                }

                var service = GetService<PackageVulnerabilityService>();

                // Act
                await service.UpdateVulnerability(vulnerability, false);

                // Assert
                Assert.Contains(existingVulnerability, context.Vulnerabilities);
                Assert.Equal(wasUpdated ? newDescription : description, existingVulnerability.Description);
                updateService.Verify();

                VerifyTransaction();
            }
        }

        public class TheUpdatePackageVulnerabilityMethod : MethodFacts
        {
            [Theory]
            [InlineData(false)]
            [InlineData(true)]
            public Task ThrowsArgumentNullExceptionIfNull(bool withdrawn)
            {
                var service = GetService<PackageVulnerabilityService>();
                return Assert.ThrowsAsync<ArgumentNullException>(() => service.UpdatePackageVulnerability(null, withdrawn));
            }

            [Theory]
            [InlineData(false)]
            [InlineData(true)]
            public Task ThrowsArgumentNullExceptionIfVulnerabilityNull(bool withdrawn)
            {
                var service = GetService<PackageVulnerabilityService>();
                var packageVulnerability = new PackageVulnerability();
                return Assert.ThrowsAsync<ArgumentNullException>(() => service.UpdatePackageVulnerability(packageVulnerability, withdrawn));
            }

            [Fact]
            public async Task WithNoExistingVulnerability_Withdrawn_DoesNotAdd()
            {
                // Arrange
                var id = "theId";
                var range = new VersionRange(NuGetVersion.Parse("1.0.0")).ToNormalizedString();
                var vulnerability = new Vulnerability();
                var packageVulnerability = new PackageVulnerability
                {
                    Vulnerability = vulnerability,
                    PackageId = id,
                    PackageVersionRange = range
                };

                vulnerability.PackageVulnerabilities.Add(packageVulnerability);

                var context = GetFakeContext();
                var updateService = GetMock<IPackageUpdateService>();
                var service = GetService<PackageVulnerabilityService>();

                // Act
                await service.UpdatePackageVulnerability(packageVulnerability, true);

                // Assert
                Assert.False(context.Vulnerabilities.AnySafe());
                Assert.False(context.PackageVulnerabilities.AnySafe());
                updateService.Verify(
                    x => x.UpdatePackagesAsync(It.IsAny<IReadOnlyList<Package>>(), It.IsAny<bool>()),
                    Times.Never);

                VerifyTransaction();
            }

            [Theory]
            [InlineData(false)]
            [InlineData(true)]
            public async Task WithExistingVulnerability_Withdrawn_RemovesAndUnmarks(bool hasExistingVulnerablePackages)
            {
                // Arrange
                var key = 1;
                var vulnerability = new Vulnerability { GitHubDatabaseKey = key };
                var existingVulnerability = new Vulnerability
                {
                    GitHubDatabaseKey = key,
                    Description = "hello"
                };

                var context = GetFakeContext();
                context.Vulnerabilities.Add(existingVulnerability);

                var updateService = GetMock<IPackageUpdateService>();
                var id = "theId";
                var range = new VersionRange(NuGetVersion.Parse("1.0.0")).ToNormalizedString();
                var packageVulnerability = new PackageVulnerability
                {
                    Vulnerability = vulnerability,
                    PackageId = id,
                    PackageVersionRange = range
                };

                if (hasExistingVulnerablePackages)
                {
                    var existingVulnerablePackage = new Package();
                    var existingDifferentPackageVulnerabilityForSameVulnerability = new PackageVulnerability
                    {
                        Vulnerability = existingVulnerability
                    };

                    context.PackageVulnerabilities.Add(existingDifferentPackageVulnerabilityForSameVulnerability);
                    existingVulnerability.PackageVulnerabilities.Add(existingDifferentPackageVulnerabilityForSameVulnerability);
                    existingDifferentPackageVulnerabilityForSameVulnerability.Packages.Add(existingVulnerablePackage);

                    updateService
                        .Setup(x => x.UpdatePackagesAsync(new[] { existingVulnerablePackage }, true))
                        .Returns(Task.CompletedTask)
                        .Verifiable();
                }

                var service = GetService<PackageVulnerabilityService>();

                // Act
                await service.UpdatePackageVulnerability(packageVulnerability, true);

                // Assert
                Assert.False(context.Vulnerabilities.AnySafe());
                Assert.DoesNotContain(packageVulnerability, context.PackageVulnerabilities);
                updateService.Verify();

                VerifyTransaction();
            }

            public static IEnumerable<object[]> WithExisting_NotWithdrawn_UpdatesPackages_Data =>
                MemberDataHelper.Combine(
                    MemberDataHelper.BooleanDataSet(),
                    MemberDataHelper.BooleanDataSet(),
                    MemberDataHelper.BooleanDataSet());

            [Theory]
            [MemberData(nameof(WithExisting_NotWithdrawn_UpdatesPackages_Data))]
            public async Task WithExistingVulnerability_NotWithdrawn_UpdatesPackages(
                bool hasExistingVulnerablePackages, 
                bool wasUpdated, 
                bool hasExistingPackageVulnerability)
            {
                // Arrange
                var key = 1;
                var description = "hello";
                var newDescription = "hi";
                var vulnerability = new Vulnerability
                {
                    GitHubDatabaseKey = key,
                    Description = wasUpdated ? newDescription : description
                };

                var existingVulnerability = new Vulnerability
                {
                    GitHubDatabaseKey = key,
                    Description = description
                };

                var context = GetFakeContext();
                context.Vulnerabilities.Add(existingVulnerability);

                var id = "theId";
                var range = new VersionRange(NuGetVersion.Parse("1.0.0")).ToNormalizedString();
                var packageVulnerability = new PackageVulnerability
                {
                    Vulnerability = vulnerability,
                    PackageId = id,
                    PackageVersionRange = range
                };

                var updateService = GetMock<IPackageUpdateService>();
                var expectedPackagesToUpdate = new List<Package>();
                var expectedVulnerablePackages = new List<Package>();
                if (hasExistingVulnerablePackages)
                {
                    // Any packages that are already vulnerable to this vulnerability but not associated with this package vulnerability should be updated if the vulnerability is updated.
                    var existingVulnerablePackage = new Package();
                    var existingDifferentPackageVulnerabilityForSameVulnerability = new PackageVulnerability
                    {
                        Vulnerability = existingVulnerability
                    };

                    context.PackageVulnerabilities.Add(existingDifferentPackageVulnerabilityForSameVulnerability);
                    existingDifferentPackageVulnerabilityForSameVulnerability.Packages.Add(existingVulnerablePackage);
                    existingVulnerability.PackageVulnerabilities.Add(existingDifferentPackageVulnerabilityForSameVulnerability);

                    expectedVulnerablePackages.Add(existingVulnerablePackage);
                    if (wasUpdated)
                    {
                        expectedPackagesToUpdate.Add(existingVulnerablePackage);
                    }
                }

                var expectedPackageVulnerability = packageVulnerability;
                var registration = new PackageRegistration
                {
                    Id = id
                };

                context.PackageRegistrations.Add(registration);
                if (hasExistingPackageVulnerability)
                {
                    expectedPackageVulnerability = new PackageVulnerability
                    {
                        Vulnerability = existingVulnerability,
                        PackageId = id,
                        PackageVersionRange = range
                    };

                    existingVulnerability.PackageVulnerabilities.Add(expectedPackageVulnerability);
                    context.PackageVulnerabilities.Add(expectedPackageVulnerability);

                    // A package that is already vulnerable but does not fit in the version range should be updated.
                    var noLongerVulnerablePackage = new Package
                    {
                        PackageRegistration = registration,
                        NormalizedVersion = "0.0.0"
                    };

                    registration.Packages.Add(noLongerVulnerablePackage);
                    context.Packages.Add(noLongerVulnerablePackage);
                    expectedPackageVulnerability.Packages.Add(noLongerVulnerablePackage);
                    expectedPackagesToUpdate.Add(noLongerVulnerablePackage);

                    // A package that is already vulnerable and fits in the version range should still be vulnerable.
                    // It should be updated if and only if the vulnerability was updated.
                    var existingVulnerablePackage = new Package
                    {
                        PackageRegistration = registration,
                        NormalizedVersion = "1.0.1"
                    };

                    registration.Packages.Add(existingVulnerablePackage);
                    context.Packages.Add(existingVulnerablePackage);
                    expectedPackageVulnerability.Packages.Add(existingVulnerablePackage);

                    expectedVulnerablePackages.Add(existingVulnerablePackage);
                    if (wasUpdated)
                    {
                        expectedPackagesToUpdate.Add(existingVulnerablePackage);
                    }
                }

                // A package that fits in the version range but is not vulnerable yet should be vulnerable and updated.
                var newlyVulnerablePackage = new Package
                {
                    PackageRegistration = registration,
                    NormalizedVersion = "1.0.2"
                };

                registration.Packages.Add(newlyVulnerablePackage);
                expectedVulnerablePackages.Add(newlyVulnerablePackage);
                expectedPackagesToUpdate.Add(newlyVulnerablePackage);

                // A package that is not vulnerable and does not fit in the version range should not be touched.
                var neverVulnerablePackage = new Package
                {
                    PackageRegistration = registration,
                    NormalizedVersion = "0.0.1"
                };

                registration.Packages.Add(neverVulnerablePackage);

                if (expectedPackagesToUpdate.Any())
                {
                    updateService
                        .Setup(x => x.UpdatePackagesAsync(expectedPackagesToUpdate, true))
                        .Returns(Task.CompletedTask)
                        .Verifiable();
                }

                var service = GetService<PackageVulnerabilityService>();

                // Act
                await service.UpdatePackageVulnerability(packageVulnerability, false);

                // Assert
                Assert.Contains(existingVulnerability, context.Vulnerabilities);
                Assert.Contains(expectedPackageVulnerability, context.PackageVulnerabilities);
                Assert.Equal(existingVulnerability, expectedPackageVulnerability.Vulnerability);
                Assert.Equal(wasUpdated ? newDescription : description, existingVulnerability.Description);
                Assert.Equal(
                    expectedVulnerablePackages.OrderBy(p => p.NormalizedVersion), 
                    context.PackageVulnerabilities.SelectMany(pv => pv.Packages).OrderBy(p => p.NormalizedVersion));

                updateService.Verify();

                VerifyTransaction();
            }
        }

        public class MethodFacts : TestContainer
        {
            public MethodFacts()
            {
                _transactionMock = new Mock<IDbContextTransaction>();
                _databaseMock = new Mock<IDatabase>();
                Context = GetFakeContext();
                UpdateServiceMock = GetMock<IPackageUpdateService>();
                Service = GetService<PackageVulnerabilityService>();

                _transactionMock
                    .Setup(x => x.Commit())
                    .Verifiable();

                _databaseMock
                    .Setup(x => x.BeginTransaction())
                    .Returns(_transactionMock.Object)
                    .Verifiable();

                Context.SetupDatabase(_databaseMock.Object);
            }

            private Mock<IDbContextTransaction> _transactionMock { get; }
            private Mock<IDatabase> _databaseMock { get; }
            protected FakeEntitiesContext Context { get; }
            protected Mock<IPackageUpdateService> UpdateServiceMock { get; }
            protected PackageVulnerabilityService Service { get; }

            protected void VerifyTransaction()
            {
                _transactionMock.Verify();
                _databaseMock.Verify();
            }
        }
    }
}
