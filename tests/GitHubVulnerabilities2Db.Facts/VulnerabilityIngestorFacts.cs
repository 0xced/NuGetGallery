// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Linq;
using System.Threading.Tasks;
using GitHubVulnerabilities2Db.GraphQL;
using GitHubVulnerabilities2Db.Ingest;
using Moq;
using NuGet.Services.Entities;
using NuGet.Versioning;
using NuGetGallery;
using Xunit;

namespace GitHubVulnerabilities2Db.Facts
{
    public class VulnerabilityIngestorFacts
    {
        public class TheAdvisoryIngestMethodFacts : MethodFacts
        {
            [Fact]
            public async Task IngestsNone()
            {
                // Act
                await Ingestor.Ingest(Enumerable.Empty<SecurityAdvisory>().ToList());

                // Assert
                PackageVulnerabilityServiceMock
                    .Verify(
                        x => x.UpdateVulnerability(It.IsAny<Vulnerability>(), It.IsAny<bool>()),
                        Times.Never);
            }

            [Theory]
            [InlineData(false)]
            [InlineData(true)]
            public async Task IngestsAdvisory(bool withdrawn)
            {
                // Arrange
                var advisory = new SecurityAdvisory
                {
                    DatabaseId = 1,
                    Description = "howdy",
                    WithdrawnAt = withdrawn ? new DateTime() : (DateTime?)null
                };

                PackageVulnerabilityServiceMock
                    .Setup(x => x.UpdateVulnerability(It.IsAny<Vulnerability>(), withdrawn))
                    .Callback<Vulnerability, bool>((vulnerability, wasWithdrawn) =>
                    {
                        Assert.Equal(advisory.DatabaseId, vulnerability.GitHubDatabaseKey);
                        Assert.Equal(advisory.Description, vulnerability.Description);
                    })
                    .Returns(Task.CompletedTask)
                    .Verifiable();

                // Act
                await Ingestor.Ingest(new[] { advisory });

                // Assert
                PackageVulnerabilityServiceMock.Verify();
            }
        }

        public class TheVulnerabilityIngestMethodFacts : MethodFacts
        {
            [Fact]
            public async Task IngestsNone()
            {
                // Act
                await Ingestor.Ingest(Enumerable.Empty<SecurityVulnerability>().ToList());

                // Assert
                PackageVulnerabilityServiceMock
                    .Verify(
                        x => x.UpdatePackageVulnerability(It.IsAny<PackageVulnerability>(), It.IsAny<bool>()),
                        Times.Never);
            }

            [Theory]
            [InlineData(false)]
            [InlineData(true)]
            public async Task IngestsVulnerability(bool withdrawn)
            {
                // Arrange
                var advisory = new SecurityAdvisory
                {
                    DatabaseId = 1,
                    Description = "howdy",
                    WithdrawnAt = withdrawn ? new DateTime() : (DateTime?)null
                };

                var securityVulnerability = new SecurityVulnerability
                {
                    Advisory = advisory,
                    Package = new SecurityVulnerabilityPackage { Name = "crested.gecko" },
                    VulnerableVersionRange = "homeOnTheRange"
                };

                var versionRange = VersionRange.Parse("[1.0.0, 1.0.0]");
                GitHubVersionRangeParserMock
                    .Setup(x => x.ToNuGetVersionRange(securityVulnerability.VulnerableVersionRange))
                    .Returns(versionRange);

                PackageVulnerabilityServiceMock
                    .Setup(x => x.UpdatePackageVulnerability(It.IsAny<PackageVulnerability>(), withdrawn))
                    .Callback<PackageVulnerability, bool>((packageVulnerability, wasWithdrawn) =>
                    {
                        Assert.Equal(securityVulnerability.Package.Name, packageVulnerability.PackageId);
                        Assert.Equal(versionRange.ToNormalizedString(), packageVulnerability.PackageVersionRange);

                        var vulnerability = packageVulnerability.Vulnerability;
                        Assert.Equal(advisory.DatabaseId, vulnerability.GitHubDatabaseKey);
                        Assert.Equal(advisory.Description, vulnerability.Description);
                    })
                    .Returns(Task.CompletedTask)
                    .Verifiable();

                // Act
                await Ingestor.Ingest(new[] { securityVulnerability });

                // Assert
                PackageVulnerabilityServiceMock.Verify();
            }
        }

        public class MethodFacts
        {
            public MethodFacts()
            {
                PackageVulnerabilityServiceMock = new Mock<IPackageVulnerabilityService>();
                GitHubVersionRangeParserMock = new Mock<IGitHubVersionRangeParser>();
                Ingestor = new VulnerabilityIngestor(
                    PackageVulnerabilityServiceMock.Object,
                    GitHubVersionRangeParserMock.Object);
            }

            public Mock<IPackageVulnerabilityService> PackageVulnerabilityServiceMock { get; }
            public Mock<IGitHubVersionRangeParser> GitHubVersionRangeParserMock { get; }
            public VulnerabilityIngestor Ingestor { get; }
        }
    }
}
