// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using GitHubVulnerabilities2Db.GraphQL;
using NuGet.Services.Entities;
using NuGet.Versioning;
using NuGetGallery;

namespace GitHubVulnerabilities2Db.Ingest
{
    /// <summary>
    /// Ingests <see cref="SecurityAdvisory"/>s and <see cref="SecurityVulnerability"/>s.
    /// </summary>
    public class VulnerabilityIngestor : INodeIngestor<SecurityAdvisory>, INodeIngestor<SecurityVulnerability>
    {
        public VulnerabilityIngestor(
            IPackageVulnerabilityService packageVulnerabilityService)
        {
            _packageVulnerabilityService = packageVulnerabilityService;
        }

        private readonly IPackageVulnerabilityService _packageVulnerabilityService;

        public async Task Ingest(IReadOnlyList<SecurityAdvisory> advisories, CancellationToken token)
        {
            foreach (var advisory in advisories)
            {
                if (token.IsCancellationRequested)
                {
                    return;
                }

                var vulnerabilityTuple = FromAdvisory(advisory);
                var vulnerability = vulnerabilityTuple.Item1;
                var wasWithdrawn = vulnerabilityTuple.Item2;
                await _packageVulnerabilityService.UpdateVulnerability(vulnerability, wasWithdrawn);
            }
        }

        public async Task Ingest(IReadOnlyList<SecurityVulnerability> securityVulnerabilities, CancellationToken token)
        {
            foreach (var securityVulnerability in securityVulnerabilities)
            {
                if (token.IsCancellationRequested)
                {
                    return;
                }

                var vulnerabilityTuple = FromAdvisory(securityVulnerability.Advisory);
                var vulnerability = vulnerabilityTuple.Item1;
                var wasWithdrawn = vulnerabilityTuple.Item2;
                var packageVulnerability = new PackageVulnerability
                {
                    Vulnerability = vulnerability,
                    PackageId = securityVulnerability.Package.Name,
                    PackageVersionRange = FromGitHubVulnerableVersionRange(securityVulnerability.VulnerableVersionRange).ToNormalizedString()
                };

                await _packageVulnerabilityService.UpdatePackageVulnerability(packageVulnerability, wasWithdrawn);
            }
        }

        private Tuple<Vulnerability, bool> FromAdvisory(SecurityAdvisory advisory)
        {
            var vulnerability = new Vulnerability
            {
                GitHubDatabaseKey = advisory.DatabaseId,
                Description = advisory.Description
            };

            return Tuple.Create(vulnerability, advisory.WithdrawnAt != null);
        }

        private VersionRange FromGitHubVulnerableVersionRange(string vulnerableVersionRange)
        {
            // Remove commas in version range. They exist solely for readability.
            vulnerableVersionRange = vulnerableVersionRange.Replace(",", string.Empty);

            // A GitHub version range consists of pairs of:
            // 1. A symbol (<, >, <=, or >=), which defines whether the next version is the minimum or maximum and whether or not it's included or excluded in the range.
            // 2. A SemVer version.
            var versionRangeParts = vulnerableVersionRange.Split(' ');
            if (versionRangeParts.Length > 4)
            {
                throw new ArgumentException("A version range cannot contain more than two pairs.");
            }

            NuGetVersion minVersion = null;
            var includeMinVersion = false;
            NuGetVersion maxVersion = null;
            var includeMaxVersion = false;

            for (var i = 0; i < versionRangeParts.Length; i += 2)
            {
                if (versionRangeParts.Length <= i + 1)
                {
                    throw new ArgumentException("The number of version range parts must be a multiple of two.");
                }

                // The symbol is the first part of the version range pair.
                var symbol = versionRangeParts[i];
                if (symbol.Length < 1 || symbol.Length > 2)
                {
                    throw new ArgumentException("Length of version range symbol must be 1 or 2.");
                }

                // The version is the second part of the version range pair.
                var version = NuGetVersion.Parse(versionRangeParts[i + 1]);
                var isMin = false;
                var isMax = false;

                switch (symbol)
                {
                    case "=":
                        isMin = true;
                        includeMinVersion = true;
                        isMax = true;
                        includeMaxVersion = true;
                        break;
                    case "<":
                        isMax = true;
                        break;
                    case "<=":
                        isMax = true;
                        includeMaxVersion = true;
                        break;
                    case ">":
                        isMin = true;
                        break;
                    case ">=":
                        isMin = true;
                        includeMinVersion = true;
                        break;
                    default:
                        throw new ArgumentException($"{symbol} is not a valid symbol in a version range.");
                }

                if (isMin)
                {
                    if (minVersion == null)
                    {
                        minVersion = version;
                    }
                    else
                    {
                        throw new ArgumentException("The minimum version is already defined for the version range.");
                    }
                }

                if (isMax)
                {
                    if (maxVersion == null)
                    {
                        maxVersion = version;
                    }
                    else
                    {
                        throw new ArgumentException("The maximum version is already defined for the version range.");
                    }
                }
            }

            return new VersionRange(minVersion, includeMinVersion, maxVersion, includeMaxVersion);
        }
    }
}
