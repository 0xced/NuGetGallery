// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using GitHubVulnerabilities2Db.GraphQL;
using NuGet.Services.Entities;
using NuGetGallery;

namespace GitHubVulnerabilities2Db.Ingest
{
    /// <summary>
    /// Ingests <see cref="SecurityAdvisory"/>s and <see cref="SecurityVulnerability"/>s.
    /// </summary>
    public class VulnerabilityIngestor : INodeIngestor<SecurityAdvisory>, INodeIngestor<SecurityVulnerability>
    {
        public VulnerabilityIngestor(
            IPackageVulnerabilityService packageVulnerabilityService,
            IGitHubVersionRangeParser gitHubVersionRangeParser)
        {
            _packageVulnerabilityService = packageVulnerabilityService;
            _gitHubVersionRangeParser = gitHubVersionRangeParser;
        }

        private readonly IPackageVulnerabilityService _packageVulnerabilityService;
        private readonly IGitHubVersionRangeParser _gitHubVersionRangeParser;

        public async Task Ingest(IReadOnlyList<SecurityAdvisory> advisories, CancellationToken token)
        {
            foreach (var advisory in advisories)
            {
                if (token.IsCancellationRequested)
                {
                    return;
                }

                var vulnerabilityTuple = FromAdvisory(advisory);
                var vulnerability = vulnerabilityTuple.Item1;
                var wasWithdrawn = vulnerabilityTuple.Item2;
                await _packageVulnerabilityService.UpdateVulnerability(vulnerability, wasWithdrawn);
            }
        }

        public async Task Ingest(IReadOnlyList<SecurityVulnerability> securityVulnerabilities, CancellationToken token)
        {
            foreach (var securityVulnerability in securityVulnerabilities)
            {
                if (token.IsCancellationRequested)
                {
                    return;
                }

                var vulnerabilityTuple = FromAdvisory(securityVulnerability.Advisory);
                var vulnerability = vulnerabilityTuple.Item1;
                var wasWithdrawn = vulnerabilityTuple.Item2;
                var packageVulnerability = new PackageVulnerability
                {
                    Vulnerability = vulnerability,
                    PackageId = securityVulnerability.Package.Name,
                    PackageVersionRange = _gitHubVersionRangeParser.ToNuGetVersionRange(securityVulnerability.VulnerableVersionRange).ToNormalizedString()
                };

                await _packageVulnerabilityService.UpdatePackageVulnerability(packageVulnerability, wasWithdrawn);
            }
        }

        private Tuple<Vulnerability, bool> FromAdvisory(SecurityAdvisory advisory)
        {
            var vulnerability = new Vulnerability
            {
                GitHubDatabaseKey = advisory.DatabaseId,
                Description = advisory.Description
            };

            return Tuple.Create(vulnerability, advisory.WithdrawnAt != null);
        }
    }
}
