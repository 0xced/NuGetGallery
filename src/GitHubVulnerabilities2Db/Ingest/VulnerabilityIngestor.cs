// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using GitHubVulnerabilities2Db.GraphQL;
using NuGet.Services.Entities;
using NuGet.Versioning;
using NuGetGallery;

namespace GitHubVulnerabilities2Db.Ingest
{
    /// <summary>
    /// Ingests <see cref="SecurityAdvisory"/>s and <see cref="SecurityVulnerability"/>s.
    /// </summary>
    public class VulnerabilityIngestor : INodeIngestor<SecurityAdvisory>, INodeIngestor<SecurityVulnerability>
    {
        public VulnerabilityIngestor(
            IPackageVulnerabilityService packageVulnerabilityService)
        {
            _packageVulnerabilityService = packageVulnerabilityService;
        }

        private readonly IPackageVulnerabilityService _packageVulnerabilityService;

        public async Task Ingest(IReadOnlyList<SecurityAdvisory> advisories, CancellationToken token)
        {
            foreach (var advisory in advisories)
            {
                if (token.IsCancellationRequested)
                {
                    return;
                }

                var vulnerabilityTuple = FromAdvisory(advisory);
                var vulnerability = vulnerabilityTuple.Item1;
                var wasWithdrawn = vulnerabilityTuple.Item2;
                await _packageVulnerabilityService.UpdateVulnerability(vulnerability, wasWithdrawn);
            }
        }

        public async Task Ingest(IReadOnlyList<SecurityVulnerability> securityVulnerabilities, CancellationToken token)
        {
            foreach (var securityVulnerability in securityVulnerabilities)
            {
                if (token.IsCancellationRequested)
                {
                    return;
                }

                var vulnerabilityTuple = FromAdvisory(securityVulnerability.Advisory);
                var vulnerability = vulnerabilityTuple.Item1;
                var wasWithdrawn = vulnerabilityTuple.Item2;
                var packageVulnerability = new PackageVulnerability
                {
                    Vulnerability = vulnerability,
                    PackageId = securityVulnerability.Package.Name,
                    PackageVersionRange = FromGitHubVulnerableVersionRange(securityVulnerability.VulnerableVersionRange).ToNormalizedString()
                };

                await _packageVulnerabilityService.UpdatePackageVulnerability(packageVulnerability, wasWithdrawn);
            }
        }

        private Tuple<Vulnerability, bool> FromAdvisory(SecurityAdvisory advisory)
        {
            var vulnerability = new Vulnerability
            {
                GitHubDatabaseKey = advisory.DatabaseId,
                Description = advisory.Description
            };

            return Tuple.Create(vulnerability, advisory.WithdrawnAt != null);
        }

        private VersionRange FromGitHubVulnerableVersionRange(string vulnerableVersionRange)
        {
            // Remove commas in version range. They exist solely for readability.
            vulnerableVersionRange = vulnerableVersionRange.Replace(",", string.Empty);
            var versionRangeParts = vulnerableVersionRange.Split(' ');

            NuGetVersion minVersion = null;
            var includeMinVersion = false;
            NuGetVersion maxVersion = null;
            var includeMaxVersion = false;

            for (var i = 0; i < versionRangeParts.Length; i += 2)
            {
                if (versionRangeParts.Length <= i + 1)
                {
                    throw new ArgumentException("Invalid number of version range parts! Must be a multiple of two!");
                }

                var symbol = versionRangeParts[i];
                if (symbol.Length < 1 || symbol.Length > 2)
                {
                    throw new ArgumentException("Length of version range symbol must be 1 or 2!");
                }

                var version = NuGetVersion.Parse(versionRangeParts[i + 1]);
                var firstSymbolPart = symbol[0];
                switch (firstSymbolPart)
                {
                    case '=':
                        minVersion = version;
                        includeMinVersion = true;
                        maxVersion = version;
                        includeMaxVersion = true;
                        break;
                    case '<':
                        maxVersion = version;
                        break;
                    case '>':
                        minVersion = version;
                        break;
                    default:
                        throw new ArgumentException($"{firstSymbolPart} is not supported!");
                }

                if (symbol.Length == 2)
                {
                    var secondSymbolPart = symbol[1];
                    if (secondSymbolPart == '=')
                    {
                        if (minVersion != null)
                        {
                            includeMinVersion = true;
                        }
                        else if (maxVersion != null)
                        {
                            includeMaxVersion = true;
                        }
                        else
                        {
                            throw new ArgumentException($"Unexpected {secondSymbolPart} in second part of symbol!");
                        }
                    }
                    else
                    {
                        throw new ArgumentException($"{secondSymbolPart} is not supported in second part of symbol!");
                    }
                }
            }

            return new VersionRange(minVersion, includeMinVersion, maxVersion, includeMaxVersion);
        }
    }
}
