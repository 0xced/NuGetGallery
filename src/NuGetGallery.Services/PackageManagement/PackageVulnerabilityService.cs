// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Collections.Generic;
using System.Data.Entity;
using System.Linq;
using System.Threading.Tasks;
using NuGet.Services.Entities;
using NuGet.Versioning;

namespace NuGetGallery
{
    public class PackageVulnerabilityService : IPackageVulnerabilityService
    {
        public PackageVulnerabilityService(
            IEntitiesContext entitiesContext,
            IPackageUpdateService packageUpdateService)
        {
            _entitiesContext = entitiesContext ?? throw new ArgumentNullException(nameof(entitiesContext));
            _packageUpdateService = packageUpdateService ?? throw new ArgumentNullException(nameof(packageUpdateService));
        }

        private readonly IEntitiesContext _entitiesContext;
        private readonly IPackageUpdateService _packageUpdateService;

        public Task UpdateVulnerability(Vulnerability vulnerability, bool wasWithdrawn)
        {
            return UpdateVulnerabilityEntity(
                UpdateVulnerabilityInternal, 
                vulnerability, 
                wasWithdrawn);
        }

        public Task UpdatePackageVulnerability(PackageVulnerability packageVulnerability, bool wasWithdrawn)
        {
            return UpdateVulnerabilityEntity(
                UpdatePackageVulnerabilityInternal, 
                packageVulnerability, 
                wasWithdrawn);
        }

        private async Task UpdateVulnerabilityEntity<TEntity>(
            Func<TEntity, bool, HashSet<Package>, TEntity> updateEntity, 
            TEntity entity, 
            bool wasWithdrawn)
        {
            using (var strategy = new SuspendDbExecutionStrategy())
            using (var transaction = _entitiesContext.GetDatabase().BeginTransaction())
            {
                var packagesToUpdate = new HashSet<Package>();
                updateEntity(entity, wasWithdrawn, packagesToUpdate);
                await _entitiesContext.SaveChangesAsync();

                if (packagesToUpdate.Any())
                {
                    await _packageUpdateService.UpdatePackagesAsync(packagesToUpdate.ToList());
                }

                transaction.Commit();
            }
        }

        private PackageVulnerability UpdatePackageVulnerabilityInternal(PackageVulnerability packageVulnerability, bool wasWithdrawn, HashSet<Package> packagesToUpdate)
        {
            if (packageVulnerability == null)
            {
                throw new ArgumentNullException(nameof(packageVulnerability));
            }

            // First, update the vulnerability that this package vulnerability is associated with.
            var updatedPackageVulnerability = packageVulnerability;
            var vulnerability = UpdateVulnerabilityInternal(updatedPackageVulnerability.Vulnerability, wasWithdrawn, packagesToUpdate);
            updatedPackageVulnerability.Vulnerability = vulnerability;

            // Determine if we already have this package vulnerability.
            var existingPackageVulnerability = vulnerability.PackageVulnerabilities
                       .SingleOrDefault(
                           pv => pv.PackageId == updatedPackageVulnerability.PackageId
                              && pv.PackageVersionRange == updatedPackageVulnerability.PackageVersionRange);

            // If the vulnerability was withdrawn, its deletion will cascade to delete this package vulnerability, so we don't need to do anything here.
            // If it has not been withdrawn, however, we need to update this package vulnerability and the packages associated with it.
            if (!wasWithdrawn)
            {
                if (existingPackageVulnerability == null)
                {
                    _entitiesContext.PackageVulnerabilities.Add(updatedPackageVulnerability);
                }
                else
                {
                    updatedPackageVulnerability = existingPackageVulnerability;
                }

                UpdatePackagesVulnerableToPackageVulnerability(
                    updatedPackageVulnerability,
                    packagesToUpdate);
            }

            return updatedPackageVulnerability;
        }

        /// <summary>
        /// Updates the database with <paramref name="vulnerability"/>.
        /// </summary>
        /// <param name="vulnerability">The <see cref="Vulnerability"/> to persist in the database.</param>
        /// <param name="wasWithdrawn">Whether or not this vulnerability has been withdrawn.</param>
        /// <param name="packagesToUpdate">The set of <see cref="Package"/>s affected by this operation that should be marked as updated.</param>
        /// <returns>
        /// If the vulnerability already exists, returns the existing vulnerability.
        /// If the vulnerability does not already exist, returns <paramref name="vulnerability"/>.
        /// </returns>
        private Vulnerability UpdateVulnerabilityInternal(Vulnerability vulnerability, bool wasWithdrawn, HashSet<Package> packagesToUpdate)
        {
            if (vulnerability == null)
            {
                throw new ArgumentNullException(nameof(vulnerability));
            }

            var updatedVulnerability = vulnerability;
            // Determine if we already have this vulnerability.
            var existingVulnerability = _entitiesContext.Vulnerabilities
                .Include(v => v.PackageVulnerabilities)
                .Include(v => v.PackageVulnerabilities.Select(pv => pv.Packages))
                .SingleOrDefault(v => v.GitHubDatabaseKey == vulnerability.GitHubDatabaseKey);

            if (existingVulnerability == null)
            {
                // We do not yet have this vulnerability. We should add it if it is not withdrawn and could affect at least one package.
                // If the vulnerability does not have any package vulnerabilities, it cannot affect any packages.
                // Even if no packages are currently vulnerable to the vulnerability, as long as it has a package vulnerability, 
                // there is at least one package that could be uploaded that would be vulnerable to it.
                if (!wasWithdrawn && vulnerability.PackageVulnerabilities.Any())
                {
                    _entitiesContext.Vulnerabilities.Add(vulnerability);
                }
            }
            else
            {
                // We already have this vulnerability, so we should update it.
                updatedVulnerability = existingVulnerability;
                var vulnerablePackages = existingVulnerability.PackageVulnerabilities.SelectMany(pv => pv.Packages);
                if (wasWithdrawn)
                {
                    // If the vulnerability was withdrawn, all packages marked vulnerable need to be unmarked and updated.
                    packagesToUpdate.UnionWith(vulnerablePackages);
                    _entitiesContext.Vulnerabilities.Remove(existingVulnerability);
                }
                else
                {
                    var wasUpdated = false;
                    if (vulnerability.Description != existingVulnerability.Description)
                    {
                        existingVulnerability.Description = vulnerability.Description;
                        wasUpdated = true;
                    }

                    if (wasUpdated)
                    {
                        // If the vulnerability's metadata was updated, all packages marked vulnerable need to be updated.
                        packagesToUpdate.UnionWith(vulnerablePackages);
                    }
                }
            }

            return updatedVulnerability;
        }

        /// <summary>
        /// Iterates through the <see cref="Package"/>s that could be vulnerable to <paramref name="packageVulnerability"/>.
        /// If any of these packages have not been marked vulnerable and should be, mark them vulnerable and add them to <paramref name="packagesToUpdate"/>.
        /// If any of these packages are marked vulnerable but should not be, unmark them and add them to <paramref name="packagesToUpdate"/>.
        /// </summary>
        private void UpdatePackagesVulnerableToPackageVulnerability(PackageVulnerability packageVulnerability, HashSet<Package> packagesToUpdate)
        {
            var versionRange = VersionRange.Parse(packageVulnerability.PackageVersionRange);
            var packages = _entitiesContext.PackageRegistrations
                .Where(pr => pr.Id == packageVulnerability.PackageId)
                .SelectMany(pr => pr.Packages)
                .ToList();

            foreach (var package in packages)
            {
                var version = NuGetVersion.Parse(package.NormalizedVersion);
                var isAlreadyVulnerable = packageVulnerability.Packages.Contains(package);
                var satisfiesVersionRange = versionRange.Satisfies(version);
                if (satisfiesVersionRange)
                {
                    if (!isAlreadyVulnerable)
                    {
                        package.Vulnerabilities.Add(packageVulnerability);
                        packageVulnerability.Packages.Add(package);
                        packagesToUpdate.Add(package);
                    }
                }
                else if (isAlreadyVulnerable)
                {
                    package.Vulnerabilities.Remove(packageVulnerability);
                    packageVulnerability.Packages.Remove(package);
                    packagesToUpdate.Add(package);
                }
            }
        }
    }
}
