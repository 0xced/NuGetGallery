// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Collections.Generic;
using System.Data.Entity;
using System.Linq;
using System.Threading.Tasks;
using NuGet.Services.Entities;
using NuGet.Versioning;

namespace NuGetGallery
{
    public class PackageVulnerabilityService : IPackageVulnerabilityService
    {
        public PackageVulnerabilityService(
            IEntitiesContext entitiesContext,
            IPackageUpdateService packageUpdateService)
        {
            _entitiesContext = entitiesContext ?? throw new ArgumentNullException(nameof(entitiesContext));
            _packageUpdateService = packageUpdateService ?? throw new ArgumentNullException(nameof(packageUpdateService));
        }

        private readonly IEntitiesContext _entitiesContext;
        private readonly IPackageUpdateService _packageUpdateService;

        public async Task UpdateVulnerability(Vulnerability vulnerability, bool wasWithdrawn)
        {
            using (var strategy = new SuspendDbExecutionStrategy())
            using (var transaction = _entitiesContext.GetDatabase().BeginTransaction())
            {
                var packagesToUpdate = new HashSet<Package>();
                var updatedVulnerability = UpdateVulnerabilityInternal(vulnerability, wasWithdrawn, packagesToUpdate);
                await _entitiesContext.SaveChangesAsync();

                if (packagesToUpdate.Any())
                {
                    await _packageUpdateService.UpdatePackagesAsync(packagesToUpdate.ToList());
                }

                transaction.Commit();
            }
        }

        public async Task UpdatePackageVulnerability(PackageVulnerability packageVulnerability, bool wasWithdrawn)
        {
            using (var strategy = new SuspendDbExecutionStrategy())
            using (var transaction = _entitiesContext.GetDatabase().BeginTransaction())
            {
                var packagesToUpdate = new HashSet<Package>();
                var vulnerability = UpdateVulnerabilityInternal(packageVulnerability.Vulnerability, wasWithdrawn, packagesToUpdate);
                packageVulnerability.Vulnerability = vulnerability;
                var existingPackageVulnerability = vulnerability.PackageVulnerabilities
                    .SingleOrDefault(
                        pv => pv.PackageId == packageVulnerability.PackageId 
                        && pv.PackageVersionRange == packageVulnerability.PackageVersionRange);

                if (!wasWithdrawn)
                {
                    if (existingPackageVulnerability == null)
                    {
                        _entitiesContext.PackageVulnerabilities.Add(packageVulnerability);
                    }

                    UpdatePackagesVulnerableToVulnerability(packageVulnerability, packagesToUpdate);
                }

                await _entitiesContext.SaveChangesAsync();

                if (packagesToUpdate.Any())
                {
                    await _packageUpdateService.UpdatePackagesAsync(packagesToUpdate.ToList());
                }

                transaction.Commit();
            }
        }

        private Vulnerability UpdateVulnerabilityInternal(Vulnerability vulnerability, bool wasWithdrawn, HashSet<Package> packagesToUpdate)
        {
            var updatedVulnerability = vulnerability;
            var existingVulnerability = _entitiesContext.Vulnerabilities
                .Include(v => v.PackageVulnerabilities)
                .Include(v => v.PackageVulnerabilities.Select(pv => pv.Packages))
                .SingleOrDefault(v => v.GitHubDatabaseKey == vulnerability.GitHubDatabaseKey);

            if (existingVulnerability == null)
            {
                if (!wasWithdrawn && vulnerability.PackageVulnerabilities.Any())
                {
                    _entitiesContext.Vulnerabilities.Add(vulnerability);
                }
            }
            else
            {
                updatedVulnerability = existingVulnerability;
                var vulnerablePackages = existingVulnerability.PackageVulnerabilities.SelectMany(pv => pv.Packages);
                if (wasWithdrawn)
                {
                    packagesToUpdate.UnionWith(vulnerablePackages);
                    _entitiesContext.Vulnerabilities.Remove(existingVulnerability);
                }
                else
                {
                    var wasUpdated = false;
                    if (vulnerability.Description != existingVulnerability.Description)
                    {
                        existingVulnerability.Description = vulnerability.Description;
                    }

                    if (wasUpdated)
                    {
                        packagesToUpdate.UnionWith(vulnerablePackages);
                    }
                }
            }

            return updatedVulnerability;
        }

        private void UpdatePackagesVulnerableToVulnerability(PackageVulnerability vulnerability, HashSet<Package> packagesToUpdate)
        {
            var versionRange = VersionRange.Parse(vulnerability.PackageVersionRange);
            var packages = _entitiesContext.PackageRegistrations
                .Where(pr => pr.Id == vulnerability.PackageId)
                .SelectMany(pr => pr.Packages)
                .ToList();

            foreach (var package in packages)
            {
                var version = NuGetVersion.Parse(package.NormalizedVersion);
                var isAlreadyVulnerable = vulnerability.Packages.Contains(package);
                var satisfiesVersionRange = versionRange.Satisfies(version);
                if (satisfiesVersionRange)
                {
                    if (!isAlreadyVulnerable)
                    {
                        package.Vulnerabilities.Add(vulnerability);
                        vulnerability.Packages.Add(package);
                        packagesToUpdate.Add(package);
                    }
                }
                else if (isAlreadyVulnerable)
                {
                    package.Vulnerabilities.Remove(vulnerability);
                    vulnerability.Packages.Remove(package);
                    packagesToUpdate.Add(package);
                }
            }
        }
    }
}
